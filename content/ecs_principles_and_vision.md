# 实体-组件-系统（ECS）原理和概览

ECS建立于一系列原则之上。这些原则为我们要实现的目标提供了良好的基础。一些原则非常清晰地反映在代码里，而另一些只是我们为自己设定的目标。

## 默认情况下的性能

我们希望能有一个简单的方法来在各个平台上生成高效的机器码。

我们的性能甚至可以和用C++手写的，高度优化过的[SIMD](https://en.wikipedia.org/wiki/SIMD)函数相提并论。

我们使用一系列方式包括编译技术（Burst），容器（Unity.Collections），数据布局（ECS）来使编写的代码一开始就是高效的。

* 数据布局和迭代 - ECS在默认情况下在批量迭代实体时保证数据布局在内存中是线性的。而这就是ECS带来的性能提升的关键因素。
* C# job system 使编写安全的多线程代码变得很简单。C# Job调试器会检测所有的线程竞争条件。
* Burst是我们专为C# jobs准备的编译器。我们让C# job代码遵循一些模式，就能生成更高效的机器码。代码在各个平台上的编译和优化都使用了SIMD指令集。

拿实例化的性能为例。根据理论上的限制，实例化10万个实体（每个320字节的内存分配）需要9毫秒，而用ECS来实现也只需要10毫秒。所以我们的性能已经非常接近理论上限了。

我们在Unite奥斯汀上展示了一个包含10万个独立实体还能跑到60fps的战争模拟的Demo。所有的业务代码都跑在多个CPU核心上。
[See ECS performance demo [Video]](https://www.youtube.com/watch?v=0969LalB7vw)

## 简单

编写高性能([performant](https://en.wiktionary.org/wiki/performant))必须十分容易。我们坚信，编写高性能的代码就像写 __MonoBehaviour.Update__ 一样容易。

> Note: 为了让大家有正确地预期，我们认为仍然有一些方法可以实现这一目标。

## 用同一种方式写代码

我们想找到一种可以同时编写游戏代码，编辑器代码，资产管线代码和引擎代码的方式。我们相信这样可以给用户提供一个更简单，更强大的工具。

物理系统就是一个绝佳的例子。目前物理相关的代码对开发者是不可见的，很多开发者都想基于他们游戏的需求来微调一下这些物理代码。如果物理引擎的代码跟游戏业务逻辑一样使用ECS，那么在现存的物理模拟代码中嵌入你自己的逻辑或者直接实现为你的版本就会变得非常容易。

另一个例子，假如你想搞一个重度依赖MOD的游戏。

如果我们的导入管线也被实现为 __ComponentSystems__ 的一部分，我们还有一些在资产管线中默认用于导入和FBX文件的后处理的FBX导入管线相关的代码（在编辑器中使用网格和FBX导入代码）。

然后配置包管理器就会变得很容易，已部署的游戏中就能使用相同的FBX的导入和后处理代码来实现MOD了。

我们相信可以在架构层面上使Unity比现在更加灵活。

## 网络

我们想用一种简单的方式来编写所有的游戏代码，遵循这种方法，根据你游戏的类型，可以使用一下三种网络架构之一。

我们专注于为托管的游戏提供最好的网络引擎。使用我们最新提供的[Multiplay.com](http://Multiplay.com)服务托管下述游戏。

* 第一人称射击（FPS） - 在服务器上进行模拟
* 即时战略（RTS） - 精确的帧同步模拟
* 街机游戏 - GGPO

> Note: 为了让大家有正确地预期，我们还没有在ECS系统中提供任何网络代码。 这个我们还在开发中。

## 确定性

我们的构建管线必须是 [确定性的](https://en.wikipedia.org/wiki/Deterministic_algorithm). 用户可以选择是否所有模拟代码都以确定性的方式运行。

无论使用什么设备，你对于同样的输入应该总是得出同样的结果。这点对于网络编程，重放功能甚至高级的调试工具都是十分重要的。

为此我们将利用Burst编译器来在不同的平台上进行同样精确的浮点数运算。比如说在Linux服务器和iOS客户端上运行着同样的浮点数运算。这对于许多场景都十分有用，尤其是网络游戏，但也包括调试和重放等。

> Note: 浮点数精度问题是Unity决定要去处理的。虽然这个问题已经存在一定时间了，然而至今为止也没有充分的需求来鼓励人们去解决这个问题。有关此问题的一些深入见解，包括避免此类问题所需的一些解决方法，可以考虑了解一下[Floating-Point Determinism by Bruce Dawson](https://randomascii.wordpress.com/2013/07/16/floating-point-determinism/).

## 沙盒

Unity是一个既安全又简单的沙盒环境。

当API没有被正确使用时，我们会提供详尽的错误信息。我们从来不会让任何不正确的调用导致崩溃，设计就是如此（而不是我们可以快速修复的bug）。

一个沙盒的绝佳的例子是我们的C# job system保证你所有的C# job代码都没有竞争条件。我们会通过结合静态代码分析和运行时检查来很确定地检查所有可能的竞争条件。我们会立即为你提供有关任何竞争条件的易读的错误信息。所以，即使是第一次编写多线程游戏代码的开发人员，也可以放心相信您的代码能够正常并且安全地工作。

## 短小精悍

我们希望Unity可以用于小至50KB，大至GB级别的所有游戏内容。对于小东西，我们想让Unity在1秒之内完成加载。

## 迭代时间

我们致力于将大型项目目录中的常见操作的迭代时间保持在小于500ms。

例如，我们正在努力重写C#编译器，以实现完全的增量编译，目标是：

> 在一个大型项目中，当你只改变一个.cs源文件时，编译+热重载的时间要小于500ms。

## 我们的代码自带全覆盖的单元测试

我们致力于从一开始就提供健壮的代码。我们使用单元测试来保证我们的代码在开发过程中能保持正确工作。测试代码将被作为包的一部分一并提供给大家。

## 进化

我们知道，我们对于编写代码的方式正在提出一个相当大的改变。即从MonoBehaviour.Update转变到ComponentSystem和Job。

我们相信，最终让开发者信服的唯一方法就是去在自己的游戏里尝试并亲眼看到结果。

所以重点是要让ECS很容易且快捷地应用于现有项目。我们的目标是30分钟内就能把一个大型项目中的一些MonoBehavior.Update改为ComponentSystem实现，还能让他有一个优化他游戏代码的成功经验。

## 包

我们希望大部分的引擎代码都用C#实现并且部署于一个包中。所有Unity Pro的订阅客户都可以访问所有源码。

我们希望可以同客户建立快速反馈的闭环，因为我们可以在不破坏其他部分的稳定性的前提下推送新的代码并同时获得反馈。

之前大部分引擎代码都是用C++实现的，这导致Unity的程序员和我们客户编写代码的方式产生了脱节。归功于Burst编译器技术和ECS，我们用C#可以比C++有更好的实现，最终结果就是我们就能以相同的方式来编写所有的代码了。

## 协作
我们相信Unity的用户的开发Unity的人可以在同一个团队中协作。我们的目标是帮助所有Unity的用户能以更高质量，优秀的性能来快速创建最好的游戏体验。

我们相信我们开发的任何功能都必须基于真实场景和来自真实生产环境的反馈来进行开发。包管理器（Package Manager）促进了这一点。

对于社区里那些想贡献引擎代码的人，我们的目标是让贡献者直接在跟我们一样的代码库上进行提交。通过明确的规则和覆盖全面的测试代码，我们希望保持社区贡献的代码也有同样高的质量。

所有Unity Pro的订阅客户都可以访问上述代码库。

## 透明公开

我们信仰透明。我们开发功能的过程始终是在论坛和博客上透明公开的。我们会保留时间以便每位开发者可以花时间了解我们用户的痛点。
